/*
 * Desarrollado por Jerson Villatoro
 */
package GramaticaFlexCup; 

import Editor.VentanaErrores;
import Interprete.Arbol;
import Interprete.Expresiones.Expresion;
import Interprete.Expresiones.Primitivo;
import Interprete.Expresiones.Operaciones.*;
import Interprete.Instrucciones.Instruccion;
import Interprete.Instrucciones.Asignacion;
import java.util.LinkedList;
import Interprete.NodoAST;
import java_cup.runtime.*;

parser code 
{:
    /**
     * Variable en la que se almacena el arbol de sintaxis abstracta que se 
     * genera luego del analisis sintáctico.
     */
    Arbol AST = null;

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
            String error = "No se esperaba este componente: " +s.value+".\n";
            error += "Se esperaba : ";
            for(int i : expected_token_ids()){
                error += symbl_name_from_id(i) + " ";
            }
            System.err.println(error);
            VentanaErrores.getVenErrores().AgregarError("Sintactico",error, s.left , s.right);
    } 
    /**
     * Método al que se llama en el momento en que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
    }  
    /**
     * Método que devuelve el AST que se generó después de realizar el análisis sintáctico. 
     * @return árbol de sintaxis abstacta que será utilizado posteriormente en la ejecución.
     */
    public Arbol getAST(){
        return AST;
    }
    
:} 

//SIGNOS DE PUNTUACION
terminal String IGUAL,PARIZQ,PARDER,LLAVEIZQ,LLAVEDER,COMA,PTCOMA,CORIZQ,CORDER,DOSPUNTOS;
terminal String IDENTIFICADOR,DCORDER,DCORIZQ,FLECHA;

//PALABRAS RESERVADAS
terminal String RNULL,RTRUE,RFALSE,RIF,RELSE,RSWITCH,RCASE,RBREAK,RCONTINUE,RWHILE;
terminal String RDO,RFOR,RIN,RFUNCTION,RRETURN,RDEFAULT;
//FIN PALABRAS RESERVADAS

//PRIMITIVOS
terminal String ENTERO, DECIMAL, CADENA;

//OPERADORES
terminal String MAS,MENOS,POR,DIV,POT,MOD;
terminal String MENOR,MAYOR,MENORIGUAL,MAYORIGUAL,IGUALQUE,DIFERENTE,UMENOS,UMAS;
terminal String AND,OR,NOT,TERNARIO;

//NO TERMINALES

//INSTRUCCIONES
non terminal INI;
non terminal LinkedList<NodoAST> L_INSTR, BLOQUE;
non terminal Instruccion INSTR,ASIGNACION,IF,ELSE,SWITCH,L_CASE,WHILE,DOWHILE,FOR,BREAK,CONTINUE;
non terminal RETURN,DEC_FUN;
non terminal L_PARAM_FORM,PARAM_FORM,CALL_FUN,L_PARAM_ACT,PARAM_ACT;

//EXPRESIONES
non terminal Expresion EXP,EXP2,EXP3,EXP_TERNARIA,PRIMITIVO,ACCESO,INDEX,L_INDEX;


//Operaciones logicas
precedence right TERNARIO;
precedence left  OR;
precedence left  AND;
precedence nonassoc NOT;

//Operaciones Relacionales
precedence left DIFERENTE,IGUALQUE;
precedence left  MENOR,MAYOR,MENORIGUAL,MAYORIGUAL;

//Operaciones numericas
precedence left  MAS,MENOS;
precedence left  POR,DIV,MOD;
precedence right UMENOS,UMAS;
precedence nonassoc POT;

start with INI; 

INI ::= 
        L_INSTR:l   {:System.out.println("EL ANÁLISIS TERMINÓ BIEN :)"); AST = new Arbol(l);:}
;

L_INSTR ::=
        L_INSTR:l INSTR:i   {:RESULT = l; RESULT.add(i);:}
    |   INSTR:i             {:RESULT = new LinkedList<NodoAST>(); RESULT.add(i);:}
;

BLOQUE ::=
        LLAVEIZQ L_INSTR:l LLAVEDER     {:RESULT = l;:}
;

INSTR ::=
        ASIGNACION:i    {:RESULT = i;:}
    |   IF
    |   WHILE
    |   DOWHILE
    |   SWITCH
    |   FOR
    |   BREAK
    |   CONTINUE
    |   RETURN
    |   DEC_FUN
    |   CALL_FUN
;

SWITCH ::=
        RSWITCH PARIZQ EXP PARDER LLAVEIZQ L_CASE LLAVEDER
    |   RSWITCH PARIZQ EXP PARDER LLAVEIZQ L_CASE RDEFAULT DOSPUNTOS L_INSTR LLAVEDER
;

L_CASE ::=
        L_CASE RCASE PRIMITIVO DOSPUNTOS L_INSTR
    |   RCASE PRIMITIVO DOSPUNTOS L_INSTR
;

CONTINUE ::=
        RCONTINUE PTCOMA
    |   RCONTINUE
;

BREAK ::=
        RBREAK PTCOMA
    |   RBREAK
;

RETURN ::=
        RRETURN PARIZQ EXP PARDER
    |   RRETURN
    |   RRETURN PARIZQ EXP PARDER PTCOMA
    |   RRETURN PTCOMA
;

WHILE ::=
    RWHILE PARIZQ EXP PARDER BLOQUE
;

DEC_FUN ::=
        IDENTIFICADOR IGUAL RFUNCTION PARIZQ L_PARAM_FORM PARDER BLOQUE
    |   IDENTIFICADOR IGUAL PARIZQ L_PARAM_FORM PARDER FLECHA BLOQUE
    |   IDENTIFICADOR IGUAL RFUNCTION PARIZQ PARDER BLOQUE
    |   IDENTIFICADOR IGUAL PARIZQ PARDER FLECHA BLOQUE
;

CALL_FUN ::=
        IDENTIFICADOR PARIZQ L_PARAM_ACT PARDER
    |   IDENTIFICADOR PARIZQ PARDER
;

L_PARAM_ACT ::=
        L_PARAM_ACT COMA PARAM_ACT
    |   PARAM_ACT
;

PARAM_ACT ::=
        RDEFAULT
    |   EXP
;

L_PARAM_FORM ::=
        L_PARAM_FORM COMA PARAM_FORM
    |   PARAM_FORM
;

PARAM_FORM ::=
        ACCESO
    |   IDENTIFICADOR IGUAL EXP
;

DOWHILE ::=
        RDO BLOQUE RWHILE PARIZQ EXP PARDER PTCOMA
    |   RDO BLOQUE RWHILE PARIZQ EXP PARDER
;

FOR ::=
        RFOR PARIZQ IDENTIFICADOR RIN EXP PARDER BLOQUE
;

ASIGNACION ::=
        IDENTIFICADOR:i IGUAL EXP:e PTCOMA      {:RESULT = new Asignacion(ileft,iright,i,e);:}
    |   IDENTIFICADOR:i IGUAL EXP:e             {:RESULT = new Asignacion(ileft,iright,i,e);:}             
    |   ACCESO IGUAL EXP
    |   ACCESO IGUAL EXP PTCOMA
;

IF ::=
        RIF PARIZQ EXP PARDER BLOQUE
    |   RIF PARIZQ EXP PARDER BLOQUE ELSE
;

ELSE ::=
        RELSE IF
    |   RELSE BLOQUE
;

EXP ::=
        EXP OR EXP
    |   EXP AND EXP
    |   EXP_TERNARIA
    |   NOT EXP
    |   EXP2:e                      {:RESULT = e;:}
;

EXP2 ::=
        EXP3:e1 MAYOR EXP3:e2       {:RESULT = new ExpRelacional(e1left,e1right,e1,e2,TipoOpe.MAYOR);:}
    |   EXP3:e1 MENOR EXP3:e2       {:RESULT = new ExpRelacional(e1left,e1right,e1,e2,TipoOpe.MENOR);:}
    |   EXP3:e1 MENORIGUAL EXP3:e2  {:RESULT = new ExpRelacional(e1left,e1right,e1,e2,TipoOpe.MENORIGUAL);:}
    |   EXP3:e1 MAYORIGUAL EXP3:e2  {:RESULT = new ExpRelacional(e1left,e1right,e1,e2,TipoOpe.MAYORIGUAL);:}
    |   EXP3:e1 IGUALQUE EXP3:e2    {:RESULT = new ExpRelacional(e1left,e1right,e1,e2,TipoOpe.IGUALQUE);:}
    |   EXP3:e1 DIFERENTE EXP3:e2   {:RESULT = new ExpRelacional(e1left,e1right,e1,e2,TipoOpe.DIFERENTE);:}
    |   EXP3:e                      {:RESULT = e;:}
;

EXP3 ::=
        MENOS EXP3:e1               {:RESULT = new ExpAritmetica(e1,e1left,e1right);:} %prec UMENOS
    |   EXP3:e1 MAS EXP3:e2         {:RESULT = new ExpAritmetica(e1left,e1right,e1,e2,TipoOpe.SUMA);:}
    |   EXP3:e1 MENOS EXP3:e2       {:RESULT = new ExpAritmetica(e1left,e1right,e1,e2,TipoOpe.RESTA);:}
    |   EXP3:e1 POR EXP3:e2         {:RESULT = new ExpAritmetica(e1left,e1right,e1,e2,TipoOpe.MULT);:}
    |   EXP3:e1 DIV EXP3:e2         {:RESULT = new ExpAritmetica(e1left,e1right,e1,e2,TipoOpe.DIV);:}
    |   EXP3:e1 POT EXP3:e2         {:RESULT = new ExpAritmetica(e1left,e1right,e1,e2,TipoOpe.POT);:}
    |   EXP3:e1 MOD EXP3:e2         {:RESULT = new ExpAritmetica(e1left,e1right,e1,e2,TipoOpe.MOD);:}
    |   CALL_FUN
    |   PARIZQ EXP:e PARDER         {:RESULT = e;:}
    |   PRIMITIVO:e                 {:RESULT = e;:}
    |   ACCESO
    |   IDENTIFICADOR
    |   RNULL
;

PRIMITIVO ::=
        ENTERO:e    {:RESULT = new Primitivo(eleft,eright,Integer.parseInt(e));:}
    |   CADENA:e    {:RESULT = new Primitivo(eleft,eright,e);:}
    |   DECIMAL:e   {:RESULT = new Primitivo(eleft,eright,Double.parseDouble(e));:}
    |   RFALSE:e    {:RESULT = new Primitivo(eleft,eright,false);:}
    |   RTRUE:e     {:RESULT = new Primitivo(eleft,eright,true);:}
;

EXP_TERNARIA ::=
        EXP TERNARIO EXP DOSPUNTOS EXP
;

ACCESO ::=
        IDENTIFICADOR L_INDEX
;

L_INDEX ::=
        L_INDEX INDEX
    |   INDEX
;

INDEX ::=
        CORIZQ EXP CORDER
    |   DCORIZQ EXP DCORDER
;